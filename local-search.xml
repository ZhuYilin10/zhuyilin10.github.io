<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录如何编译使用 OpenCV Contrib for Android SDK</title>
    <link href="/2023/03/20/compile-opencv-contrib-sdk-for-Android/"/>
    <url>/2023/03/20/compile-opencv-contrib-sdk-for-Android/</url>
    
    <content type="html"><![CDATA[<p>好久好久没写 blog 了，上次写还是 2019 年，真是漫长的一段时间。</p><p>今天想记录一下如何编译 OpenCV Contrib for Android SDK。</p><p>作为一个对 NDK 和 C&#x2F;C++ 几乎完全不懂的人 最近在研究如何做一个很简单的事情 说起来就由公司研究 OpenCV 的同事写一段 C++ 的函数 调用 opencv 来实现某个功能 而我在 Android 和 iOS 端分别写一个 C 函数来调用同事写的代码 打包为库 最后由 kotlin&#x2F;swift 调用我自己的这个函数。</p><h2 id="如何编译最简单的-so-库"><a href="#如何编译最简单的-so-库" class="headerlink" title="如何编译最简单的 so 库"></a>如何编译最简单的 so 库</h2><p>这里需要用到 NDK 和 JNI。<br>这里简单记录一下文件构成。</p><p>Android.mk</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">LOCAL_PATH := <span class="hljs-variable">$(<span class="hljs-built_in">call</span> my-<span class="hljs-built_in">dir</span>)</span><br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(CLEAR_VARS)</span><br><br>LOCAL_CPPFLAGS += -frtti -fexception<br>LOCAL_CPP_FEATURES := rtti exceptions<br><br>OPENCV_LIB_TYPE:=STATIC<br>OPENCV_INSTALL_MODULES:=on<br><span class="hljs-keyword">include</span> ../../../libs/sdk/native/jni/OpenCV.mk<br><br>LOCAL_MODULE    := version<br>LOCAL_SRC_FILES := version.cpp main.c<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(BUILD_SHARED_LIBRARY)</span><br><br></code></pre></td></tr></table></figure><p>Application.mk</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">APP_ABI := all<br>APP_PLATFORM := android-19<br>APP_STL := c++_shared<br>APP_CPPFLAGS += -fexceptions -frtti<br>APP_CPP_FEATURES := exceptions rtti  <br></code></pre></td></tr></table></figure><p>main.c</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#include &lt;stdio.h&gt;</span><br><span class="hljs-meta">#include &lt;stdlib.h&gt;</span><br><span class="hljs-meta">#include &lt;string.h&gt;</span><br><span class="hljs-meta">#include &lt;jni.h&gt;</span><br><br>extern const char* getOpenCVVersion();<br><br>JNIEXPORT jstring JNICALL<br>Java_com_example_cppcp_OpencvUtils_getOpenCVVersion(JNIEnv *env, jobject thiz) &#123;<br>    const char* version = getOpenCVVersion();<br>    return (*env)-&gt;NewStringUTF(env, version);<br>&#125;  <br></code></pre></td></tr></table></figure><p>version.cpp</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="hljs-meta">#include &lt;iostream&gt;</span><br><br>extern <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    const char* getOpenCVVersion() &#123;<br>        return CV_VERSION;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些文件都是在 app&#x2F;src&#x2F;main&#x2F;jni 中，ndk-build 来编译，当然不要忘记在 build.gradle 中添加 jni sorceSet</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">sourceSets &#123;<br>  main &#123;<br>    jniLibs.srcDirs = [<span class="hljs-string">&#x27;src/main/libs&#x27;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是最简单的输出 OpenCV ncv version 的例子。<br>但是同事用到了 SURF 算法等相关，即需要调用 xfeatures2d 相关内容。<br>但是官网下载的OpenCV是没有SIFT和SURF算法的，因为这些算法是受专利保护的，所以并没有被包含在预编译库中，所以如果想要使用SIFT和SURF算法，需要自己来编译OpenCV Android SDK。</p><h2 id="如何编译"><a href="#如何编译" class="headerlink" title="如何编译"></a>如何编译</h2><p>其实 OpenCV 的 SDK 中是含有编译脚本的 我们不再需要使用 CMake 来自己编译 只是我们需要加入参数来进行编译 这里对命令做一个简单记录。</p><p>需要下载 OpenCV 的源码 而不是官网编译好的 Android SDK。</p><p>在下载的内容中 在 platforms&#x2F;android 目录下 可以找到 build_sdk.py 这就是编译脚本。</p><p>以下是我调用的命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">python3 Downloads<span class="hljs-regexp">/opencv-4.7.0/</span>platforms<span class="hljs-regexp">/android/</span>build_sdk.py \<br>--extra_modules_path workspaces<span class="hljs-regexp">/opencv_contrib/m</span>odules/ \<br>--config Downloads<span class="hljs-regexp">/opencv-4.7.0/</span>platforms<span class="hljs-regexp">/android/</span>ndk-<span class="hljs-number">25</span>.config.py  <br></code></pre></td></tr></table></figure><p>非常简单的命令。</p><p>首先是 extra_modules_path 这是需要额外编译进去的 module 的路径 我们从 GitHub 下载 opencv_contrib 的源码 extra_modules_path 也就是 opencv_contrib 目录下的 modules目录。</p><p>然后是需要选择 config 这里是需要选择跟我们 NDK 版本对应的 config.py 我这里是 NDK-25 版本 所以我们选择了 ndk-25.config.py</p><p>然后执行编译就行了 我的 M1 pro 大概花了十几分钟的样子。</p><p> 最后在编译成功的 SDK 目录下可以发现我们需要的 xfeatures 文件 也就是编译成功了。</p><p> 目前这里是 Android 编译 OpenCV Contrib SDK 的方法和使用。iOS 的还没研究 研究完后将再次写文章以记录 以免日后忘记。</p>]]></content>
    
    
    
    <tags>
      
      <tag>android opencv ndk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目迁移至 AndroidX</title>
    <link href="/2019/07/08/migrate-androidx/"/>
    <url>/2019/07/08/migrate-androidx/</url>
    
    <content type="html"><![CDATA[<p>根据 Android Developer 的文档，我们可以看到：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">AndroidX </span>是 <span class="hljs-keyword">Android </span>团队用于在 <span class="hljs-keyword">Jetpack </span>中开发、测试、打包和发布库以及对其进行版本控制的开源项目。<br><span class="hljs-keyword">AndroidX </span>对原始 <span class="hljs-keyword">Android </span>支持库进行了重大改进。与支持库一样，<span class="hljs-keyword">AndroidX </span>与 <span class="hljs-keyword">Android </span>操作系统分开提供，并与各个 <span class="hljs-keyword">Android </span>版本向后兼容。<span class="hljs-keyword">AndroidX </span>完全取代了支持库，不仅提供同等的功能，而且提供了新的库。<br></code></pre></td></tr></table></figure><p>也就是说，由于在后续版本中，会逐步放弃对 support lib 的升级和维护，所以我们必须迁移到 AndroidX。<br>对于一个项目，迁移到 AndroidX 的步骤非常简单。<br>我们选择 Refactor -&gt; Migrate to AndroidX<br><img src="https://s2.ax1x.com/2019/07/08/Zr0gaD.png" alt="refactor"><br><img src="https://s2.ax1x.com/2019/07/08/ZrBeQ1.png" alt="refactor"><br>依次点击 Refactor 我们可以发现经过长时间的 index 后，项目将成功地迁移至 AndroidX，此时我们可以看到项目中原有的包名为 support 的库将依次迁移至 Androidx 对应的包名。<br>另外我们可以观察发现，在项目的 gradle.properties 文件中多了两行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">android.useAndroidX</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">android.enableJetifier</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>在官方文档中我们可以看到</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">android.useAndroidX：如果设置为 </span>true，<span class="hljs-keyword">Android </span>插件会使用相应的 <span class="hljs-keyword">AndroidX </span>库，而非支持库。如果未指定，则该标记默认为 false。<br><span class="hljs-keyword">android.enableJetifier：如果设置为 </span>true，<span class="hljs-keyword">Android </span>插件会重写其二进制文件，自动迁移现有的第三方库以使用 <span class="hljs-keyword">AndroidX。如果未指定，则该标记默认为 </span>false。<br></code></pre></td></tr></table></figure><p>不过再给公司的项目迁移至 AndroidX 的时候还是发现了很多意料之外的问题。<br>第一个也是最主要的就是大量第三方库的报错与失效。<br>很多的库提供了专门的适配了 AndroidX 的版本，比如运用于 RecycleView 的著名框架 CymChad:BaseRecyclerViewAdapterHelper，非常优秀的框架，并且良心的提供了 AndroidX 对应版本。<br>不过也有比较麻烦的事情，比如我们在使用 kotlin 时使用的 kotterKnife。<br>在我迁移项目之前，kotterKnife 还并没有支持 AndroidX（不过不知道现在是否支持)，于是我就动了把整个 ButterKnife.kt 拷进项目加以修改的年头。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;V : View&gt;</span> AppCompatActivity.<span class="hljs-title">bindView</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span><br>        : ReadOnlyProperty&lt;AppCompatActivity, V&gt; = required(id, viewFinder)<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;V : View&gt;</span> Fragment.<span class="hljs-title">bindView</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span><br>        : ReadOnlyProperty&lt;Fragment, V&gt; = required(id, viewFinder)<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;V : View&gt;</span> Fragment.<span class="hljs-title">bindOptionalView</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span><br>        : ReadOnlyProperty&lt;Fragment, V?&gt; = optional(id, viewFinder)<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;V : View&gt;</span> AppCompatActivity.<span class="hljs-title">bindOptionalView</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span><br>        : ReadOnlyProperty&lt;AppCompatActivity, V?&gt; = optional(id, viewFinder)<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> AppCompatActivity.viewFinder: Finder&lt;AppCompatActivity&gt;<br>        <span class="hljs-keyword">get</span>() = &#123; findViewById(it) &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> Fragment.viewFinder: Finder&lt;Fragment&gt;<br>        <span class="hljs-keyword">get</span>() = &#123; view!!.findViewById(it) &#125;<br></code></pre></td></tr></table></figure><p>就这样适配了 AndroidX 中 Fragment 和 Activity。<br>另外的问题就是一些 UI 方面的失效，不过修起来还是比较容易的，毕竟都是可以通过代码来控制的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android AndroidX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为 WebView 添加超时</title>
    <link href="/2018/12/19/webview-timeout/"/>
    <url>/2018/12/19/webview-timeout/</url>
    
    <content type="html"><![CDATA[<p>在手机程序开发中，网页成为一个非常重要的部分，在一些复杂的效果显示上，网页有着远超原生的便捷性，所以现在很多页面都会使用 WebView 进行加载，但是在复杂的页面显示时由于资源过大或者别的原因，可能会出现超时。但是在我希望对 WebView 进行一个 timeout 参数设置的时候，发现 WebView 本身没有提供相应的设置。<br>一开始，我选择了和网上大多开发者一样的方法进行超时的设置，即在 WebViewClient 中的 onPageStarted 时启动一个计时器，在到时间后获取页面加载进度，判断是否已经加载完成，如果没有完成则进行错误的处理。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">lateinit <span class="hljs-keyword">var</span> disposable: Disposable<br>override fun <span class="hljs-title function_">onPageStarted</span><span class="hljs-params">(view: WebView, url: String?, favicon: Bitmap?)</span> &#123;<br>                disposable = Observable.timer(<span class="hljs-number">10L</span>, TimeUnit.SECONDS).observeOn(AndroidSchedulers.mainThread()).subscribe &#123;<br>                    <span class="hljs-keyword">if</span> (view.progress &lt; <span class="hljs-number">100</span>) &#123;<br>                        view.pauseTimers()<br>                        view.stopLoading()<br>                        loadSubject!!.onError(Throwable(<span class="hljs-string">&quot;页面超时&quot;</span>))<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">super</span>.onPageStarted(view, url, favicon)<br>            &#125;<br></code></pre></td></tr></table></figure><p>但后来发现 RxJava 自身提供了一个 timeout 的函数进行操作。</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golo">对原始<span class="hljs-keyword">Observable</span>的一个镜像，如果过了一个指定的时长仍没有发射数据，它会发一个错误通知<br>如果原始<span class="hljs-keyword">Observable</span>过了指定的一段时长没有发射任何数据，Timeout操作符会以一个onError通知终止这个<span class="hljs-keyword">Observable</span>。<br></code></pre></td></tr></table></figure><p>这样我们在 webview.load() 的时候对网页添加超时，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span>: Observable&lt;String&gt; &#123;<br>        <span class="hljs-keyword">return</span> webView.load().timeout(<span class="hljs-number">10L</span>, SECONDS).onErrorResumeNext &#123; throwable: Throwable -&gt;<br>            <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">is</span> TimeoutException) &#123;<br>                <span class="hljs-keyword">return</span><span class="hljs-symbol">@onErrorResumeNext</span> Observable.error(Throwable(<span class="hljs-string">&quot;页面加载失败，请稍后重试&quot;</span>))<br>            &#125;<br>            Observable.error(throwable)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>很简洁，很好懂。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android RxJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用原生取代 WebView —— ImageSpan</title>
    <link href="/2018/03/19/about-imagespan/"/>
    <url>/2018/03/19/about-imagespan/</url>
    
    <content type="html"><![CDATA[<p>好累的两周。<br>经历了上海的房子被二房东收回去，自己说没得住就没得住，经历了辞职，经历了苏州找房，现在还在上海短租着上着班，漂泊不定，整个人会很沮丧，想想真的很难受。这个时候感觉自己应该干点什么事情，比如把之前想总结的 ImageSpan 的用法给写了。<br>ImageSpan 是图文混排中最重要的一部分，TextView 之所以能做到图文混排也就是因为 ImageSpan 的存在。<br>首先看一下最简单的本地图片的加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">TextView</span> <span class="hljs-variable">textView</span> <span class="hljs-operator">=</span> findViewById(R.id.image_span);<br><br><span class="hljs-type">SpannableString</span> <span class="hljs-variable">spannableString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpannableString</span>(<span class="hljs-string">&quot;0000000ddddddddd&quot;</span>);<br><span class="hljs-type">Drawable</span> <span class="hljs-variable">drawable</span> <span class="hljs-operator">=</span> ContextCompat.getDrawable(<span class="hljs-built_in">this</span>, R.drawable.ic_launcher_foreground);<br>drawable.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());<br>spannableString.setSpan(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageSpan</span>(drawable), <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);<br><br>textView.setText(spannableString);<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/af31670dgy1fpieygy22nj20ii0y4jso.jpg" alt="本地图片加载"><br>当然我们可以通过拼接的方式，多个 SpannableString 组合成为一个 SpannableBuilder 来加载多张图片，但是值得注意的是， drawable 必须要 setBounds，Drawable的setBounds方法有四个参数，setBounds(int left, int top, int right, int bottom),这个四参数指的是drawable将在被绘制在canvas的哪个矩形区域内。这里的单位是 px 不是 dp。建议自己写一个 DisplayUtils 或者使用 Kotlin 提供的 anko 库等方式来转换。</p><p>但是我们使用本地图片的时候终究少，更多时候我们会使用网络图片，如何加载网络图片就成了一个新的问题，我在开发的时候选择的方案是第三方图片加载框架的配合使用。这里要注意的是，加载图片应该是在子线程完成，然后主线程刷新的。<br>首先我们需要创建一个 BitmapDrawable 的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">URLDrawable</span> : BitmapDrawable() &#123;<br>    <span class="hljs-keyword">var</span> drawable: Drawable? = <span class="hljs-literal">null</span><br><br>    override fun <span class="hljs-title function_">draw</span><span class="hljs-params">(canvas: Canvas)</span> &#123;<br>        <span class="hljs-keyword">if</span> (drawable != <span class="hljs-literal">null</span>) &#123;<br>            drawable!!.draw(canvas)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们就要开始写这个 AsyncTask 了。这里提一下 AsyncTask，它是 Android 提供的一个助手类，它对 Thread 和 Handler 进行了封装，方便我们使用。Android 之所以提供 AsyncTask 这个类，就是为了方便我们在后台线程中执行操作，然后将结果发送给主线程，从而在主线程中进行UI更新等操作。<br>直接放代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageGetterAsyncTask</span>(<span class="hljs-keyword">private</span> val context: Context, <span class="hljs-keyword">private</span> val urlDrawable: URLDrawable, val url: String) : AsyncTask&lt;TextView, Void, Bitmap?&gt;() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> textView: TextView? = <span class="hljs-literal">null</span><br><br>    override fun <span class="hljs-title function_">doInBackground</span><span class="hljs-params">(vararg params: TextView)</span>: Bitmap? &#123;<br>        textView = params[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            Picasso.get().load(url).get()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            <span class="hljs-literal">null</span><br>        &#125;<br>    &#125;<br><br>    override fun <span class="hljs-title function_">onPostExecute</span><span class="hljs-params">(bitmap: Bitmap?)</span> &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">bitmapDrawable</span> <span class="hljs-operator">=</span> BitmapDrawable(context.resources, bitmap)<br>        bitmapDrawable.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br>        urlDrawable.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br>        urlDrawable.drawable = bitmapDrawable<br>        urlDrawable.invalidateSelf()<br>        textView!!.invalidate()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里一定要把 textview 传进来，因为这样我们才能实现刷新 UI 的目的。<br>我选用的是 Picasso 来加载图片，当然还可以选择其他的框架，只要稍作修改就可以了。<br>最后是 URLImageParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">URLImageParser</span>(<span class="hljs-keyword">private</span> val textView: TextView, <span class="hljs-keyword">private</span> val context: Context) &#123;<br><br>    fun <span class="hljs-title function_">getDrawable</span><span class="hljs-params">(url: String)</span>: Drawable &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">urlDrawable</span> <span class="hljs-operator">=</span> URLDrawable()<br>        ImageGetterAsyncTask(context, urlDrawable, url).execute(textView)<br>        <span class="hljs-keyword">return</span> urlDrawable<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于使用，则很简单，因为我们已经拿到了一个 drawable 的对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">val</span> <span class="hljs-variable">drawableFromNet</span> <span class="hljs-operator">=</span> URLImageParser(textView, <span class="hljs-built_in">this</span>).getDrawable(<span class="hljs-string">&quot;https://www.baidu.com/img/bd_logo1.png&quot;</span>)<br>drawableFromNet.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br>spannableString.setSpan(ImageSpan(drawableFromNet), <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, Spanned.SPAN_INCLUSIVE_EXCLUSIVE)<br></code></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/af31670dgy1fpiezr5gfrj20ii0y4gmu.jpg" alt="网络图片加载"><br>最后还有一种是特殊的情况，就是加载 database 64 图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">val</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> ByteArrayInputStream(Base64.decode(imageDataBytes.toByteArray(), Base64.DEFAULT))<br><span class="hljs-type">val</span> <span class="hljs-variable">bitmap</span> <span class="hljs-operator">=</span> BitmapFactory.decodeStream(stream)<br><span class="hljs-type">val</span> <span class="hljs-variable">bitmapDrawable</span> <span class="hljs-operator">=</span> BitmapDrawable(env.resources, bitmap)<br>bitmapDrawable.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, widthInt, heightInt)<br>spannableString.setSpan(TransYImageSpan(bitmapDrawable, env.px2dip(exVerticalAlign.toInt())), <span class="hljs-number">0</span>, spannableString.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)<br>builder.append(spannableString)<br></code></pre></td></tr></table></figure><p>代码已上传 Github <a href="https://github.com/ZhuYilin10/ImageSpan">ImageSpan</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 Android 7.0 适配踩过的一个坑</title>
    <link href="/2018/02/25/fileUri/"/>
    <url>/2018/02/25/fileUri/</url>
    
    <content type="html"><![CDATA[<p>还是上次适配 Android O 的 Adaptive Icons 时候留下的一个大坑。。。。。。<br>测试的同事确认没什么问题可以发布新版本了，开开心心上线后发现我们自己的手机一更新就会崩溃，而测试的同事却没有问题，赶紧撤下上线了的版本，经检查发现原来同事的手机还运行着 Android 4.4，而我们的手机已经是 Android 8.0。<br>在我们适配 Android 8.0 的时候将 compileSdkVersion 和 targetSdkVersion 的版本都升级到了 26，由此带来的问题就是没有注意到 Android 7.0 以上的新特性，具体 Android N 的全新特性可以查看<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html">Android 7.0 行为变更</a>。<br>在 Android 7.0 以前，在下载新版本 apk 后，使用 Intent 安装 apk 文件的代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">val</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> Intent(Intent.ACTION_VIEW)<br>intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK<br><span class="hljs-type">val</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> File(Environment.getExternalStorageDirectory() + <span class="hljs-string">&quot;/download/&quot;</span> + <span class="hljs-string">&quot;app.apk&quot;</span>)<br><span class="hljs-type">val</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.fromFile(file)<br>intent.setDataAndType(uri, <span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span>)<br></code></pre></td></tr></table></figure><p>但在 Android N 上，为了更好的控制权限和注重安全隐私，Google 进行了全新的规定：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">对于面向 Android <span class="hljs-number">7.0</span> 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:<span class="hljs-regexp">//</span> URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。<br>要在应用间共享文件，您应发送一项 content:<span class="hljs-regexp">//</span> URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。如需了解有关权限和共享文件的详细信息，请参阅共享文件。<br></code></pre></td></tr></table></figure><p>当然本身这项适配工作并没有难度，这里也只是记录一下适配的方法。<br>首先是第一步，在清单文件中进行申明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&lt;manifest&gt;<br>    <span class="hljs-string">...</span><br>    &lt;application&gt;<br>        <span class="hljs-string">...</span><br>        &lt;provider<br>            android<span class="hljs-function">:name</span>=<span class="hljs-string">&quot;android.support.v4.content.FileProvider&quot;</span><br>            android<span class="hljs-function">:authorities</span>=<span class="hljs-string">&quot;com.xxxx.fileprovider&quot;</span><br>            android<span class="hljs-function">:exported</span>=<span class="hljs-string">&quot;false&quot;</span><br>            android<span class="hljs-function">:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>            <span class="hljs-string">...</span><br>        &lt;<span class="hljs-string">/provider</span>&gt;<br>        <span class="hljs-string">...</span><br>    &lt;<span class="hljs-string">/application</span>&gt;<br>&lt;<span class="hljs-string">/manifest</span>&gt;<br></code></pre></td></tr></table></figure><p>接下来我们要创建resource xml file:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">paths</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">files-path</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my_docs&quot;</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;docs/&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">paths</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里需要解释一下，在paths节点内部支持以下几个子节点：<br><strong><root-path/> 代表设备的根目录new File(“&#x2F;“);</strong><br><strong><files-path/> 代表context.getFilesDir()</strong><br><strong><cache-path/> 代表context.getCacheDir()</strong><br><strong><external-path/> 代表Environment.getExternalStorageDirectory()</strong><br><strong><external-files-path>代表context.getExternalFilesDirs()</strong><br><strong><external-cache-path>代表getExternalCacheDirs()</strong><br>我们可以根据位置的不同选择对应的节点。<br>当然创建了文件之后我们需要在清单文件中注明。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.v4.content.FileProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.xxxx.fileprovider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/provider_paths&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个时候基本的配置已经完成了，我们还需要在代码中做一个版本的判断。回到我们 install apk 的方法。<br>Uri 不能单纯的通过 Uri.fromFile() 函数来完成，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> uri = <span class="hljs-keyword">if</span> (SDK_INT &gt;= N) &#123;<br>  intent.add<span class="hljs-constructor">Flags(Intent.FLAG_GRANT_READ_URI_PERMISSION)</span><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FileProvider</span>.</span></span>get<span class="hljs-constructor">UriForFile(<span class="hljs-params">this</span>, <span class="hljs-string">&quot;com.xxxx.fileprovider&quot;</span>, <span class="hljs-params">file</span>)</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Uri</span>.</span></span>from<span class="hljs-constructor">File(<span class="hljs-params">file</span>)</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>完成之后提交合并打包，然后再一次尝试应用内升级，一步成功～<br>不得不说，以后需要多阅读 Android 的官方文档，尤其是涉及新版本适配的时候，很多坑完全是可以避免的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用原生取代 WebView —— 图文混排 1</title>
    <link href="/2018/02/22/html2original/"/>
    <url>/2018/02/22/html2original/</url>
    
    <content type="html"><![CDATA[<p>这篇总结博客想写很久了，一直没空动笔，很羞愧。今天终于有空坐下来，2018年的第一篇技术总结，写写2017年下半年花了很多心思做的使用原生取代 WebView，也就是原生实现图文混排及交互的功能。<br>我们公司是做英语作业平台的，所以我们的核心功能就是试卷，学生们通过我们的软件完成填空题，选择题，文本题等各种题型。在以往我们的试卷部分是通过 WebView 由前端开发的同事写好交互，我们通过调用 JS 代码来实现功能，但我一直对于这样的混合开发保持怀疑，毕竟对于手机，尤其是碎片化严重的 Android 来说，不同的系统版本不同的厂家甚至不同的用户习惯都会带来 WebView 性能差甚至加载出现问题的情况，所以我们的项目实现原生图文混排及交互的功能势在必行。<br>原生图文混排及交互，也就是富文本。iOS 的同事在拿到这个任务的时候选择了 iOS 著名的富文本库 <a href="https://github.com/ibireme/YYText">YYText</a>，而负责 Android 端的我选择了使用原生 TextView 来实现，使用 SpannableString 以及 SpannableStringBuilder 来构造。<br>SpannableString 与 SpannableStringBuilder 是非常强大的，我们对于 TextView 所想实现的所有功能和样式几乎都可以通过它来完成。最简单的例子就是多种颜色的一段文字。<br>如图所示。<br><img src="https://ws1.sinaimg.cn/large/af31670dgy1fople7zmr8j20ma14u75o.jpg" alt="多种颜色文字"><br>如果是针对整个 TextView 来设置颜色是无法达到这样的效果的，我们需要用 SpannableString 设置不同的 span 后拼接，这样可以达到这样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">textView</span> <span class="hljs-operator">=</span> findViewById&lt;TextView&gt;(R.id.sample_text)<br><span class="hljs-type">val</span> <span class="hljs-variable">spannableStringBuilder</span> <span class="hljs-operator">=</span> SpannableStringBuilder()<br><br><span class="hljs-type">val</span> <span class="hljs-variable">blueString</span> <span class="hljs-operator">=</span> SpannableString(<span class="hljs-string">&quot;Hello&quot;</span>)<br>blueString.setSpan(ForegroundColorSpan(ContextCompat.getColor(<span class="hljs-built_in">this</span>, R.color.colorPrimary)), <span class="hljs-number">0</span>, blueString.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)<br>spannableStringBuilder.append(blueString)<br><br><span class="hljs-type">val</span> <span class="hljs-variable">redString</span> <span class="hljs-operator">=</span> SpannableString(<span class="hljs-string">&quot;Hello&quot;</span>)<br>redString.setSpan(ForegroundColorSpan(ContextCompat.getColor(<span class="hljs-built_in">this</span>, R.color.colorAccent)), <span class="hljs-number">0</span>, redString.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)<br>spannableStringBuilder.append(redString)<br><br>textView.text = spannableStringBuilder<br></code></pre></td></tr></table></figure><p>这里需要提及的是 setSpan 这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">setSpan(Object what, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> flags)<br></code></pre></td></tr></table></figure><p>这里备注一下几个参数对应的含义。<br>第一个参数 Object what 指的是我们需要设置的 Span 的类型，如我们显示字体颜色的 ForegroundColorSpan；<br>第二个参数 int start 以及第三个参数 int end 指的是我们对于这段 spannableString 设置样式的起始位置；<br>而第三个参数也就是 flag 的取值如下</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Spannable. SPAN<span class="hljs-emphasis">_INCLUSIVE_EXCLUSIVE：前面包括，后面不包括，即在文本前插入新的文本会应用该样式，而在文本后插入新文本不会应用该样式</span><br><span class="hljs-emphasis">Spannable. SPAN_INCLUSIVE_INCLUSIVE：前面包括，后面包括，即在文本前插入新的文本会应用该样式，而在文本后插入新文本也会应用该样式</span><br><span class="hljs-emphasis">Spannable. SPAN_EXCLUSIVE_EXCLUSIVE：前面不包括，后面不包括</span><br><span class="hljs-emphasis">Spannable. SPAN_EXCLUSIVE_</span>INCLUSIVE：前面不包括，后面包括<br></code></pre></td></tr></table></figure><p>这样就可以基本实现通过设置 span 来达到不同的效果。<br>这是使用 span 的总结第一篇，为自己后面列个提纲</p><ol><li>ImageSpan 包括 本地图片用法 网络图片用法 Data Base64图片加载方法</li><li>clickableSpan</li><li>特殊化的自定义 Span</li><li>如何在 TextView 指定位置插入 View</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决太坑的 svg 资源向下兼容性问题记录</title>
    <link href="/2017/10/11/about-compat/"/>
    <url>/2017/10/11/about-compat/</url>
    
    <content type="html"><![CDATA[<p>终于合并了上次做的 Adaptive Icon 的分支，但发现服务器跑不过去，一看是由于没有升级 gradle 等对应配置文件的问题。<br>当升级过后，发现了一个很大的问题。我们早早使用了 SVG 作为图片资源文件，取代了体积较大的 .png 文件。一直以来的做法是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>          </span><br><span class="hljs-tag"> <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/xxxxxxxx&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>但现在发现我们的用法是错误的。经过踩坑简单记录一下正确的方法，可以解决向下兼容性问题。<br>首先，需要在 build.gradle 配置文件中添加</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">defaultConfig</span> &#123;<br>        vectorDrawables.useSupportLibrary <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>      &#125;<br></code></pre></td></tr></table></figure><p>然后引入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.android.support:appcompat-v7:<span class="hljs-number">26</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>&#x27;<br></code></pre></td></tr></table></figure><p>第三步就是将 ImageView 属性设置为如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>          </span><br><span class="hljs-tag"> <span class="hljs-attr">app:srcCompat</span>=<span class="hljs-string">&quot;@drawable/xxxxxxxx&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>到此为低版本加载 SVG 的方法。当然 Android 5.0 以上不存在这个问题。<br>另外提一句，这一切是在 Activity 父类为 AppCompatActivity 的情况下进行，如果 Activity 继承自 Activity，那么应该使用 android.support.v7.widget.AppCompatImageView, 因为当使用 AppCompatActivity 时会自动将 ImageView 包装为 AppCompatImageView。<br>另一个问题就是 Textview 显示 SVG 图片的问题，这是使用比较多的地方，我们在使用 android:drawableRight 属性的时候会倒入 SVG 图像，但是这样做的结果就是低版本的奔溃。事实上，AppCompatTextView 是没有对 CompoundDrawable 进行适配的，所以我们的解决方法是代码手工写，判断系统版本如果小于5.0，就用 ContextCompat.getDrawable 获取到 Drawable 实例，再 setCompoundDrawablesWithIntrinsicBounds。建议自己定义一个 TextView，免去手写烦恼，为了节省时间，我用了一个开源库， <a href="https://github.com/woxingxiao/VectorCompatTextView">VectorCompatTextView</a>，谢谢作者分享这个库。<br>当然我说的 ContextCompat.getDrawable 获取到 Drawable 实例然后赋值的方法是最好用的方法，当个别 XML 解决不了的时候, 如 ImageView 想设置 background 但没有那么一个叫做 backgroundCompat 属性的时候建议这样写。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">imageView.background = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ContextCompat</span>.</span></span>get<span class="hljs-constructor">Drawable(<span class="hljs-params">context</span>, R.<span class="hljs-params">drawable</span>.<span class="hljs-params">xxxxxxxx</span>)</span><br></code></pre></td></tr></table></figure><p>当然今天只是简单记录一下，这几天有一些东西需要记录，包括多渠道打包配置文件，还有 Linux 安装体验，包括重装系统后恢复 blog 的记录。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Oreo 新特性适配 —— Adaptive Icons</title>
    <link href="/2017/09/12/about-oreo-1/"/>
    <url>/2017/09/12/about-oreo-1/</url>
    
    <content type="html"><![CDATA[<p>美国日全食那天，一段很短的视频带来了 Android Oreo 的正式版本，怀着激动的心情拿出了我日日把玩的 Nexus 5X，升级到了正式版本。<br>流畅。<br>我只能这么说，虽然不至于感受到宣传中提到的提升，但流畅的操作让我非常舒服。<br>可是一切感觉在看到图标后变了。<br><img src="https://user-images.githubusercontent.com/16117136/30329107-ec88fb50-9803-11e7-8964-1e51c6f62ea6.png" alt="图标"><br>这方方的图标看的我也方方的。7.X时代圆润的圆形图标呢！<br>灰溜溜刷回了Lineage OS，并在知乎上喷了一通。<a href="https://www.zhihu.com/question/64259646/answer/218605483">我的回答</a>。<br>可是在 Pixel 上确是华丽丽的圆形图标，好看整齐得让人心醉。<br>那么同样的 icon 为什么在不同的手机上会显示不同的样子呢。<br>那就是 Android 8.0 的新特性 Adaptive Icons。<br>前不久刚刚为公司的产品匹配了这一特性，踩了点坑但基本上很顺畅，写下来作为笔记。<br>首先第一步，绝对是先使用 Android Studio 3.0，现在的版本是 Android Studio 3.0 Beta 4。<br>然后就是要将项目的 targetSdkVersion 升级至 26 的版本，当然随之要变动的就是 compileSdkVersion 的版本，系统不会允许 compileSdkVersion 版本低于 targetSdkVersion。然后就是相应 support 库的升级，跳过不谈，这些准备工作做好后开始新图标的使用。<br><img src="https://user-images.githubusercontent.com/16117136/30329538-1f430dd2-9805-11e7-8a7b-88ef5d1a6bd7.png" alt="步骤1"><br>点击后出现了如下的页面。<br><img src="https://user-images.githubusercontent.com/16117136/30330043-8b79df66-9806-11e7-9859-0d9caa6d5154.png" alt="步骤2"><br>这里我们就可以看到官方提供的 Android 小人的 icon 示意图，各种形态，那么 Android 是怎么做到的呢？<br>我们可以看到它是由两个图层组成的，一个叫做 Foreground 前景，一个叫做 background 背景。<br>前景可以是一张 .png 图片，大小为 108 * 108，具体可以参见 Google 官方文档。<br>背景是一张矢量图 drawable 或者 纯色背景，这样 Android 在启动器的要求下可以选取适当的外框。<br>我们使用 Android Studio 导入图标后可以看到一个叫做 mipmap-anydpi-v26 的目录，里面是一个 xml 文件，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">adaptive-icon</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">background</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@color/ic_launcher_background&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreground</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_foreground&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">adaptive-icon</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点进去我们再看两张前后景图片的代码：<br>背景</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ic_launcher_background&quot;</span>&gt;</span>#FFFFFF<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>前景自然就是我们叫做 ic_launcher_background 的图片了。<br>当然这个时候的项目里还有 ic_launcher，这个是在不能使用 Adaptive Icons 情况下使用的图标。最后我们需要的是在项目的清单文件中注明</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>icon=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span><br></code></pre></td></tr></table></figure><p>让然有必要还有 round Icon 属性。<br>这里不得不说 Google 的套路，我理解 Google 想要统一 Android 图标的想法，但是在 Android 7 时推出的 round Icon 仅仅一代版本就遭到了弃用，现在形成了 Android 7 以下使用原来的图标，形态各异，Android 7 使用只有Android 7可以使用的 round Icon，统一的圆形图标，当然不排除很多无良厂家拿着一个奇奇怪怪的图标也称呼其为 round Icon，而 Android 8开始使用自适应图标。看得出 Google 在不断的探索 Android 的未来方向，就是系统层级相对集中的管理，包括图标、电池、权限等元素，而不是任由各种产品随意设计的以前的状况，这对于 Android 是好事，对于开发者也是好事，对于热爱 Android 的也是好事。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关于 Android 隐式启动 Activity</title>
    <link href="/2017/07/01/about-intent/"/>
    <url>/2017/07/01/about-intent/</url>
    
    <content type="html"><![CDATA[<p>忽然发现，半年没有更新过 Blog 了。。。。。<br>好尴尬，本来这个用来记录自己技术的平台是打算每月至少更新一两次，记录一下这段时间的收获的，可是由于懒散和换了电脑后环境的问题，一直没有继续写。<br>今天谈一下 Intent 的隐式启动。<br>这是一个很入门级的问题，但由于之前没用过所以也没管过，既然上周做了今天就写一下自己的体验。<br>Intent 是平时最常用的组件，我们平时用于页面跳转的就是显示 Intent。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">val</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> Intent(<span class="hljs-built_in">this</span>, SecondActivity::class.java)<br>intent.putExtra(<span class="hljs-string">&quot;.....&quot;</span>, ......)<br>startActivity(intent)<br></code></pre></td></tr></table></figure><p>而隐式启动则是通过 url 的跳转来实现的。<br>首先是 url 的结构。<br>虽然我们不是做网页的但是我们要明白，一个完整的 url 是由哪几部分构成的。<br>url一般主要由Schema、Host、Path以及QueryParameter等构成。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Schema</span> 访问协议<br><br>Host 域名<br><br>port 端口<br><br>pathName 路径名<br><br>QueryParameter 查询参数<br></code></pre></td></tr></table></figure><p>我们使用 intent.data 可以接收到这个uri。<br>这里要提一下 uri 和 url 的区别。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">首先，URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>而<span class="hljs-built_in">URL</span>是uniform resource locator，统一资源定位器，它是一种具体的URI，即<span class="hljs-built_in">URL</span>可以用来标识一个资源，而且还指明了如何locate这个资源。<br>而URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。<br>也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而<span class="hljs-built_in">URL</span>和URN则是具体的资源标识的方式。<span class="hljs-built_in">URL</span>和URN都是一种URI。<br><br>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而<span class="hljs-built_in">URL</span>类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema必须被指定。<br></code></pre></td></tr></table></figure><p>我们使用 intent.data 接收到的是一个 Uri 的对象，我们可以通过该对象获取到我们需要的信息。<br>我的做法是建立一个 UrlDispatcher，在 application 中初始化，用来接受和处理 url。<br>要实现隐式跳转的第一步就是在清单文件中注册 Intent 过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">   <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ui.common.account.UserNameActivity&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">&quot;singleTop&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.BROWSABLE&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;zhuyl&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就可以接收到域名协议为 zhuyl 的 url 了。<br>再来看看我们的 UrlDispatcher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> actions: MutableMap&lt;String, (MutableMap&lt;String, String&gt;) -&gt; Unit&gt; = HashMap()<br><span class="hljs-type">val</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> uri.host + uri.path<br><span class="hljs-type">val</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> (url.endsWith(<span class="hljs-string">&quot;/&quot;</span>)) url.dropLast(<span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> url<br><br>val params: MutableMap&lt;String, String&gt; = HashMap()<br>uri.queryParameterNames.forEach &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> uri.getQueryParameter(it)<br>    params[it] = parameter<br>&#125;<br><br>actions[action]?.invoke(params)<br></code></pre></td></tr></table></figure><p>而我们根据 action 来判断调用的方法。<br>举个例子。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">zhuyl:<span class="hljs-regexp">//</span>open_link<span class="hljs-regexp">/?url=https:/</span><span class="hljs-regexp">/baidu.com</span><br></code></pre></td></tr></table></figure><p>通过我们的代码解析后，可以得到 action 为 “open_link”<br>那么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">actions[<span class="hljs-string">&quot;open_link&quot;</span>] = &#123; params -&gt;<br>   <span class="hljs-type">val</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> Intent(application, SecondActivity::class.java)<br>   <span class="hljs-type">val</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> params[<span class="hljs-string">&quot;url&quot;</span>]<br>   intent.putExtra(<span class="hljs-string">&quot;url&quot;</span>, url)<br>   intentToActivity(intent)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做，我们在调用 url 启动 activity 的时候就可以拥有一种比较优雅的跳转方式了。<br>当然，从网页端发出的跳转也就可以处理了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2016年终总结</title>
    <link href="/2016/12/31/about-my-career-2016/"/>
    <url>/2016/12/31/about-my-career-2016/</url>
    
    <content type="html"><![CDATA[<p>呀，2016年的最后一天上班还有两个小时就结束了，然后就是回去女朋友身边跨年了～～讲真有点迫不及待了&#x3D;&#x3D;<br>好吧，总结一下2016吧。<br>2016的一月到三月，在无锡，NIIT。<br>非常不要命的一段时间，以前我觉得自己可能真的没有学开发的天赋，过年来之前代码写的一塌糊涂，真的一塌糊涂，尴尬<br>不过年后开始了项目阶段，做一个商城应用，不知道怎么，怎么说呢，就像一下子开窍了，自己突然就好像学会了开发，虽然基础知识还是不足，但是可以查啊，查了记住就好了。虽然写的都是垃圾代码，但我终于能熟练的开发一款应用了。所以真的，开发不是靠什么记笔记，就是靠实战，实战，实战。因为当你需要的时候，真的会去查，而且不达目的不罢休，所以当我做毕业设计《<a href="https://github.com/ZhuYilin10/XiaoBai">小白</a>》的时候，真的很顺心。年后到找工作前的那段时间，真的很疯狂，每天会写到十二点，一点的代码，完成了大大小小三个应用，自己去理解，去研究。<br>接下来就是心累的求职阶段了。</p><p>真的很惨，虽然四次面试拿到三个offer，但是真的只有四次面试，而我投了无数封简历。在出发去上海前的一周，没有电话，没有电话，陷入了无比的绝望，互联网寒冬，没有工作经验的开发人员，还是移动应用开发人员根本无人青睐，都快怀疑自己为什么要学 Android 开发了，但我喜欢啊。<br>不过还好，碰上了我现在的公司。<br>讲真，领导是个很有趣的人，面试的时候一开始完全跟不上领导的节奏，领导语序快思维快，让我经历了一场头脑风暴，面试前半部分表现的很差，领导合上了电脑似乎没什么兴趣，我也是抱着面不上的心喊住了领导开始放松聊天，聊技术聊科技聊手机结果意外地聊的非常开心，领导说他不关心我现在技术怎么样，反正刚毕业都有限的很，只要喜欢开发愿意学就可以。当时还在想我技术还行啊。。。。。<br>于是我发现这是一个误会，我的技术真的不还行。。。。。<br>进公司的时候，给我配了一台 MacBook Pro，讲真，第一次用 Mac，虽然玩过黑苹果但是真的用来开发我就一脸蒙蔽了，环境都配不来。。。。。。。。。。。。。。。。。。。。。。。。。。好吧现在用的还算舒服，有空可以总结一下Mac的基本使用，反正在同事的帮助下装好了环境，可以写代码了，我们用的是敏捷开发，这也是第一次接触。当时习惯了本地增删改查的代码，公司封装的很深的代码让我连服务器请求数据都不会，然后领导就带着我重构代码，几乎就是重写，后来遇到了与JS交互，我写了整整一个月，搞不清楚数据结构，搞不清楚一切，看得出来公司同事对我的失望。。。。。。。。。那段时间真的都快得抑郁症了，跟同事也不熟悉，经常一天不说话。。。。<br>不过一切都会好的，代码写多了发现自己Java水平进步了很多，然后遇到了开发生涯的两件大事，一个是 Material Design 的改版，一个是 Kotlin 语言的使用。这两件事对我来说非常重要，真的很重要，第一件事情让一直崇尚 Material Design 风格的我真正能够系统性的学习 Material Design 的使用，有设计图，由设计规范，有一个喜欢吹毛求疵的领导，我踩了很多坑，但是也真的学会了很多关于MD的内容，MD是一种非常简洁优雅的设计，相信我，一定会成为主流。再然后就是 Kotlin 语言的使用。讲真，整个项目使用纯 Kotlin 的项目不知道有哪些，但是我觉得一定不多，我们就是其中之一。用惯了 Java 这样的语言（非常垃圾的Java）真心觉得 Kotlin 非常伟大，它的高级函数和它的扩展性简直让人着迷，加上他与其他语言语法上的相近让我更是在以后自学JS、Swift的时候感觉到轻松。<br>当然在上海我最好的兄弟<a href="http://www.zhangzirui.com/">ZZR</a>在技术上也是在不断进步，没有和他的不断争论和探讨我可能也不会开始前端的学习，也不会去追求那么多新的东西。<br>————————————————————————————————————————————————————————分割线———————————————————————————————————————————————————————————————————————<br>好了上面是代码层面的东西，说的乱七八糟，我也不知道说了啥，好了说说新的一年。<br>首先最重要的事情是，我妈开了金口，让我春节期间把女朋友带回家！！！好吧，我也到了见父母的时候了，女朋友是我成为一个程序员前后最重要的人，我们有过争吵，有过矛盾，但是我们更多的是相互的谅解，我希望也会努力，最大的努力让这段感情能走到最后，最后让她为我穿上婚纱。。。。。。好了扯远了，不过明年怎么样我真的还不知道，因为想要结婚可能一个很大的问题就是买房，上海的房价真的吃不消，苏州可能是一个选择。<br>但是技术永远是美好的。<br>世界上所有的坚持，都是因为热爱。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Career</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Material Design 学习笔记 2</title>
    <link href="/2016/12/15/about-material-design-2/"/>
    <url>/2016/12/15/about-material-design-2/</url>
    
    <content type="html"><![CDATA[<p>好久没更新Blog了，当初说想保持常更新来记录自己在开发道路上的事情，结果也是没做到，作为一个有女朋友爱看电视爱写代码的开发人员来说，每天的时间都花在了陪女朋友、看电视剧和写代码上，好吧我知道开发人员怎么能有女朋友呢。。。但我就是有，而且在我眼中是非常可爱漂亮我很爱她（捂脸）～～～<br>好了以上依旧是废话。&#x3D;&#x3D;<br>前几天在北京举办的的Google开发者大会（Google Develop Day），官方宣布了Google Developers中国网站发布，怀着激动的心情关掉了代理，登录了developer.android.google.cn。快的令人感动，404世界什么时候回来还不知道，但是，至少我们看到了希望。<br>继续说说Material Design。<br>首先要说的就是Toolbar。这是一个标准的Material Design组件，在Android应用中，被大量使用。在Android 3.0时Android推出了ActionBar，ActionBar 过去最多人使用的两大套件就是 ActionBarSherlock 以及官方提供在 support library v7 里的 AppCompat。而Toolbar的推出，很大程度就是用来取代ActionBar的。</p><p>当我们的Activity继承自AppCompat的时候，会默认看到ActionBar，为了使用全新的Toolbar或者其他布局我们可以选择在Style中，对Theme进行设置，将AppTheme 的parent设置为Theme.AppCompat.Light.NoActionBar。这样我们可以看到一个没有ActionBar的空白Activity。然后我们就可以在XML文件中放进Toolbar组件。<br>当然我们会注意到一个问题，就是toolbar的阴影。我们知道在Material Design中由于材料的层次高度会像自然界中一样存在着阴影，具体可以参考知乎和Bilibili等非常符合设计规范的APP。但是如何给toolbar增加阴影，Google后发现一般给出的答案是在toolbar下加一层阴影图片，一个view。。。。但后来我发现了一个组件叫做AppbarLayout。<br>AppBarLayout 是继承LinerLayout实现的一个ViewGroup容器组件，它是为了Material Design设计的App Bar，支持手势滑动操作。当我们将AppbarLayout和Toolbar配合使用的时候，就会得到我们想要的阴影效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.AppBarLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.Toolbar</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/toolbar&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:minHeight</span>=<span class="hljs-string">&quot;56dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:titleTextColor</span>=<span class="hljs-string">&quot;@color/white&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v7.widget.Toolbar</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.AppBarLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而这个时候我们发现，我们无法设置Toolbar的文字颜色。我们可以使用设置主题的方式来设置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CC.ToolbarWhiteTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Widget.Design.CollapsingToolbar&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textColorSecondary&quot;</span>&gt;</span>@color/white<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以自定义Toolbar的布局。以知乎中的一个界面为例。<br>知乎的一个界面<br>我们可以看到知乎的Toolbar从左至右依次是title、share 的 icon和三个小圆点。<br>话说那些用惯iOS程序的人看到有些Android特色的设计几乎都是一脸懵逼。。。。。包括公司的iOS开发，我在投屏演示功能的时候他们几乎都不能理解toolbar里的三个小圆点、FloatingActionBar和下拉刷新时候不动的界面但是出现的小圈。。。。他们觉得好蠢但我是发自内心的觉得比iOS的风格好看好吗。。。。。果粉勿喷。<br>title的使用很简单，因为toolbar本身就带那么一个属性，我们可以直接设置toolbar.setTitle &#x3D; “……”来实现。分享按钮同样简单，即在布局中加入这个icon并添加点击事件，一般有baseactivity的可以在里面抽一个函数出来方便之后使用。<br>关于三个点，我们可以在res中建立一个package叫做menu，与layout、style等平级，然后实现父类的onCreateOptionsMenu函数，并将menu映射进去。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">override fun <span class="hljs-title function_">onCreateOptionsMenu</span><span class="hljs-params">(menu: Menu)</span>: Boolean &#123;<br>  menuInflater.inflate(R.menu.aaaaaa, menu)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onCreateOptionsMenu(menu)<br>&#125;<br></code></pre></td></tr></table></figure><p>顺便说一句，我用的是Kotlin，我们公司可能是比较早将Android项目全部使用Kotlin的公司了，Kotlin的本质与Java类似，但是语法上很多高级函数和他的扩展性让人欲罢不能，有坑，等有空可以总结一下。<br>今天大概写到这里，我想去陪女朋友了，这几天有事请假没有上班，刚好可以陪自己的女朋友，我一个人在上海工作，日常不在她身边，真的辛苦她了。代码重要，女朋友更重要。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Material Design 学习笔记 1</title>
    <link href="/2016/11/07/about-material-design-1/"/>
    <url>/2016/11/07/about-material-design-1/</url>
    
    <content type="html"><![CDATA[<p>首先，安利我最喜欢的手机品牌： HTC。<br>2012年我高中毕业的暑假，入手了第一款 Android 智能手机——HTC的one S，这是一款非常让人心动的产品，双核 + 1G内存的配置在那个时代也是仅次于诸如三星s3、HTC one X等旗舰的存在，但相比于同学手中的iOS，我们不得不承认，即使是以华丽而著称的Sense UI，也是足够的简陋，更不用说原生UI。Android 总有那么多让我不满意的地方，还好Android可以刷机，百度云ROM是我刷的第一个ROM，当然还有以后的MIUI。<br>好了，以上都是废话，我想表达的只是那个时候的 Android 真的很不好看，或者说。。。丑陋。<br>所以当Google 2013年 I／O大会公布了全新设计风格 —— Material Design，我的感觉只有“惊艳”能形容。<br>当然，后来由于对 Android 的执着和喜爱，我也成为了一名 Android 开发。并且在毕业设计，一款名叫《小白》的应用中把自己对Material Design 简陋的理解用了上去（真的很简陋，没有美工的痛啊…）。<br>刚刚进入公司的时候，公司的 Android 应用也是采用了与 iOS 相符的设计，后来新风格改版，采用了 Material Design。这次的改版也让我更加深入地去了解 Material Design 的开发，包括 Android Design Support Library 等的使用。<br>在学习的过程中我翻译了一篇有关于 Material Design 的文章。</p><h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><h3 id="Material-Design-的真正价值"><a href="#Material-Design-的真正价值" class="headerlink" title="Material Design 的真正价值"></a>Material Design 的真正价值</h3><p>Google 的 Material Design 在设计中是最有影响力的一种视觉理念。因为明确 了设计和可用性指南，它成为塑造人们看到并与接口交互的方式。<br>但是，Material Design 已经超越了 Google 和 Android 程序本身。<br>设计师们在很多层面使用这种设计理念——尤其是分层接口的概念。顾名思义， 也就是分层叠加多个元素。就好像一副卡片，要创造一个单一而又统一的体验，那 就是功能性和美观性。<br>让我们来谈谈 Material Design。<br>分层的概念元素在一个接口并不是一个新概念。然而,Material Design 则更进 一步,触觉体验结合大胆的和充满活力的审美。<br>在我们继续之前，让我们先确认一下我们在同样的页面上什么是 Material Design。让我们来看一下:<br>Material Design 是 Google 的一种设计理念，它概述了在移动设备上应用程序 应该如何工作。他打破了一切——包括动画、风格、布局，给了模式、组件和可用 性以指导。<br>Google 是这么说的:“我们挑战了自己，为我们的用户创造了一个综合好的设 计的经典原则的创新的设计语言和科技的可行性。这就是 Material Design。”<br>Material Design 开始于手机，但很快就扩展到其他设备上。它包括以下几个原则:<br>1.现实的视觉元素:设计就是基于现实，就好像在用纸张和墨水进行设计。<br>2.大胆的、形象的和故意的:基本设计技术驱动了视觉效果，排版、网格、空 间、比例、颜色和图像主导着整个设计，理论建立在一个用清晰的层次结构定义了 的空间上，颜色和类型的选择是大胆的而又经过深思熟虑的。<br>3.手势提供了意义:动画是 Material Design 的一个关键的组成部分，但它不 能仅仅为了移动而动。动画需要发生在一个单独的环境,重点设计和服务于包括简 单和容易的转换。动作和手势应该客观的反映物理世界。</p><p>理解“触觉表面”的含义</p><p>还有一个我们经常在布局接口会谈论到的事情是“触觉表面”。 我们可以想象一下很多张纸叠在一起来构造一个框架来进行设计是如何实现<br>的。这些纸和现实生活中的纸还是有点不同的，因为他们的形状和形式可以任意修<br>改——如拉伸和弯曲——但他们以一种看似真实的方式工作着。<br>如一篇文章《Mobile Design Trends 2015 &amp; 2016》中提到的，把触觉表面当 做一个容器来容纳信息。在设计中容器本身是平的，但有一个淡淡的阴影来区别其 他的容器和分层。当然还有其他方法来在层级之间做间隔——比如纹理和渐变—— 当然这其实是没必要的。<br>以一个很好的 app Reddit 为例，你可以清晰地看见它层级之间的分隔。有一个 冒险的顶级菜单层包含着主要内容，甚至是分层的主要顶部图像包含元素和阴影强 调三维触觉表面。<br>据文章《Android Lollipop UI Kit》证明:一个触觉表面可以清晰地确定内容 在设计方面的功能和联系(每一个容器都有自己的本质工作，比如说一个链接或者 一个视频播放器)。这种方法同样建立了深度，因为其他容器元素是分层的，由此 创建了一个三维世界</p><p>MATERIAL DESIGN 是一个自适应的设计</p><p>分层接口的本质是为了适应设计，所有的设计指导方针实际上是鼓励设计师使用一种自适应的布局(但是，你是否喜欢自适应的布局还有待考证)。 当我们考虑分层接口的时候，考虑两个元素之间的关联是非常重要的。 Google 给出的设计标准中提到:“灵活地使用网格，可以保证布局的一致性、断点的内容在不同的屏幕可以实现回转，并且描述了 app 如何从小屏幕适应到超大 型的屏幕。”<br>注意事项包括:</p><p>断点:宽度包括 480, 600, 840, 960, 1280, 1440 和 1600 像素。<br>网格:12 列的有边缘的网格和一个基线网格。<br>表面行为:UI 适应屏幕的类型所以他的表面是可见或者隐藏的。<br>绘制:功能根据屏幕的大小，包含显示、转变、扩张、回流和分离。 这些注意事项确保了设计师的适应性接口在任何情况任何设备上可以使用。它们为设计师提供了一个基础来构建在桌面、平板电脑、手机上的布局。<br>MATERIAL DESIGN 和其他设计的趋势</p><p>当涉及到分层界面时，其他设计趋势也会发挥自己的作用。<br>Material Design 从平面美学和其他流行的技术借鉴了大量的设计理念，事实上，很多人认为 Material Design 非常接近平面设计 2.0，因为很多视觉效果非常 相像。<br>单独的分层界面从完全平面设计转变过来需要创造更多的三维空间和明暗度。 本质上来说，设计师们在扁平化设计上已经带回了一些经验，但有所不同的是，他 们利用这些技术来提高可用性，而不是单纯为了装饰。<br>分层设计的颜色最大程度上满足扁平化设计的审美，而其中最大的不同就是 Google 提供了大量的颜色选项。面板颜色是一样的——明亮、大胆以及充分的饱和 的颜色。<br>很多设计师在设计的时候选择了红色和蓝色进行设计，但似乎更多的部分喜欢 深紫色和黄色，这可能是因为这些颜色更容易搭配白色和黑色的文本。<br>接口分层在极简主义的空间里也表现的非常好，特别是在排版方面。清晰地层 级和无衬线的字体是首选。Google 建议使用 Roboto 为主要字体，它有很多选择， 从常规到粗体到斜体。<br>这样的多样化帮助用户在原理上进行导向。按照极简主义，只要你按照适当的 模型和比例，一种字体几乎可以做到所有的事情。<br>现在你已经很难找到一个网站没有全屏的图像以及进一步生动的使用分层接口 的。<br>比如这个 Field Trip 的 app，如上文所述，使照片最大化的发挥价值，表示 Material Design 不仅仅是使用颜色、照片和视觉冲击效果——他们都是设计的一 个组成部分。<br>最后，就像我们之前讨论的那样，分层接口最终表现为卡片的形式。透过实例 我们可以看到，几乎所有的设计都包含了类似于卡片的设计，从小卡片到全屏幕选 项，这些趋势携手并进。</p><p>谁是下一个?</p><p>Google 在 7 月发布了几个新的指导方针，Material Design Lite，由此，所有 设计人员都可以使他们的网站或者应用程序看起来像 Android 程序。<br>就像《Mobile Design Trends 2015 &amp; 2016》一书中建议的那样，我们可能会<br>越来越多的看到 Android 的特点，可能甚至会在 ios 应用和别的地方。Material Design 看起来非常的不错，而且他在很多地方表现的非常好。设计者将会利用 lite 版本提供的完美指导水平。<br>Material Design Lite 也是一种很好的工具,可以让设计人员和开发人员想要 创建一个统一的应用体验整个 Android 和 iOS 平台时使用，让应用看起来和使用起 来有一致的用户体验，哪怕在不同的设备上面。<br>图层一定会停留一段时间，但是整体可能看起来会是更分层以及更少的材料。 所以那种设计会间与 Material Design Lite 和 ios 的设计标准之间。<br>ios 的应用 Weather Channel 已经使用了这种方法。整个应用基于卡片、色彩 和图像，在卡片的使用、图像的几何形状方面等方面理论是重叠的。因为缺乏深度 和模仿导致整个 app 看起来更加可以修改。<br>渐变和单色的图层也在以另一种方式增长着。Monochromatic color palettes 是一个经典的设计技术，它使得创建的元素几乎可以适用于任何类型的内容。<br>ios 应用 Elevate 使用了一个渐变的背景在它的设计上，它的动画和运动形态 非常符合 Material Design 的标准，当然，使用渐变色不是。这个简单的亮点使得 使得设计开始打破传统的规则而不影响其原有的功能。<br>设计师们会在更深的颜色和色调方面继续发扬分层接口和 Material Design。 现在多数的 app 都采用了浅色和白色的设计风格，但更多的深色风格即将出现。<br>Weather TimeLiness 就是一个很好的例子。简单的改变颜色就足以使这款应用 脱颖而出。它分层的风格非常明显，但深色界面使得它看起来简洁而又优雅。整个 设计看起来更饱和、缓和和具有深色的审美。<br>顺便说一句。今天这样的分层接口设计仍然只是一个开始，作为设计师成长的 一部分，简单的视觉风格和高可用性的设计风格仍然会继续出现，不仅仅是在 Android 上，而是会引领整个潮流。更有趣的是，分层界面的外观本身就是一个可 扩展的设计技术，在未来几年，包括极简主义和平面设计主义在内的设计风格将会 变得越来越流行。<br>在某种程度上，这种设计风格可能会撼动那些拟物化的设计风格很多，但那些 事情发生之前，这个概念似乎已经完全站稳了脚跟，变得真实。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几天前写的比较</title>
    <link href="/2016/11/06/additional-cursor/"/>
    <url>/2016/11/06/additional-cursor/</url>
    
    <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>最近做了一个学生成绩排序的功能，我们的需求是首先按照学生作业是否完成排序，然后按照学生成绩高低排序，最后按照学生的名字进行排序，并且可以使用 Spinner 进行来回选择，让老师可以自由对学生进行排序。</p><h2 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h2><p>在 Java 中对于集合或者数组不是单纯的数字时，一般可以选择使用 Collections.sort 或者 Arrays.sort 函数来对对象进行排序。<br>Collections.sort 函数的用法是将一个 Comparator 对象传入。<br>首先是自定义 Comparator 对象，一般是方法有两种，通常可以使用Comparator或Comparable，在这里我选择了实现 Comparator 接口来完成排序。如下是一个学生分数升序的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">inner <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortByPaperScopeAsc</span> : Comparator&lt;Student&gt; &#123;<br>    override fun <span class="hljs-title function_">compare</span><span class="hljs-params">(w1: Student, w2: Student)</span>: Int &#123;<br>        <span class="hljs-type">val</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> h1?.score ?: <span class="hljs-string">&quot;-1&quot;</span><br>        <span class="hljs-type">val</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> h2?.score ?: <span class="hljs-string">&quot;-1&quot;</span><br>        <span class="hljs-keyword">return</span> v2.compareTo(v1)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但这里仅仅是满足一项需求，而不能做到满足多种条件排序。如我们再写一个需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">inner <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortByStatusDesc</span> : Comparator&lt;Student&gt; &#123;<br>    override fun <span class="hljs-title function_">compare</span><span class="hljs-params">(h1: Student, h2: Student)</span>: Int &#123;<br>      <span class="hljs-type">val</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> (h1?.homeworkIsFinished) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>      <span class="hljs-type">val</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> (h2?.homeworkIsFinished) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> v2.compareTo(v1)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要满足已完成作业的排在前面，未完成作业的排在后面，然后对已完成作业的学生按分数升序排列。<br>毫无疑问的写法是直接定义一个排序的Comparator满足这样的需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">inner <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortByStatusAndScore</span> : Comparator&lt;Student&gt; &#123;<br>  override fun <span class="hljs-title function_">compare</span><span class="hljs-params">(w1: Student, w2: Student)</span>: Int &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">compare</span> <span class="hljs-operator">=</span> SortByStatusDesc().compare(w1, w2)<br>        <span class="hljs-keyword">if</span> (compare == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">val</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> w1?.score ?: <span class="hljs-string">&quot;-1&quot;</span><br>            <span class="hljs-type">val</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> w2?.score ?: <span class="hljs-string">&quot;-1&quot;</span><br>            <span class="hljs-keyword">return</span> v1.compareTo(v2)<br>        &#125;<br>        <span class="hljs-keyword">return</span> compare<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样一来当我们按多种条件排序时，这样的写法无疑会出现代码出现大量的重复，这个时候我们可以考虑对这种方法进行封装，可以把不同的排序条件进行组合。<br>下面是我写的一个比较类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComposeComparator</span>&lt;T&gt; : Comparator&lt;T&gt; &#123;<br>  val comparators: Array&lt;out Comparator&lt;T&gt;&gt;<br>  constructor(vararg comparators: Comparator&lt;T&gt;) &#123;<br>      <span class="hljs-built_in">this</span>.comparators = comparators<br>  &#125;<br>  override fun <span class="hljs-title function_">compare</span><span class="hljs-params">(o1: T, o2: T)</span>: Int &#123;<br>      comparators.forEach &#123;<br>          <span class="hljs-type">val</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> it.compare(o1, o2)<br>          <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">return</span> result<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用vararg，也就是可变长参数将不同的条件依次传入，可以做到不同单一排序方法的组合使用，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ComposeComparator(SortByStatusDesc(), SortByScopeAsc(), SortByNameAsc()))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
